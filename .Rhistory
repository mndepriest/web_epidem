t(matrix_1)
# Instead, 10 is added to every value within our matrix.
# Therefore, we need to dictate to R which 't' function should be applied by specifying the package name in the following format (package::function):
# If we want to use base 't' to transpose the matrix:
base::t(matrix_1)
# Here, we show how to use the 'help' and '?' functions to pull up information on a function 'cor.test':
help(cor.test)
?(cor.test)
knitr::include_graphics("figures/intro_r/help.png")
knitr::include_graphics("figures/intro_r/tidyverse.png")
# Load tidyverse
library(tidyverse)
# See the current work directory:
getwd()
# Use the function 'setwd()' with the path to your desired work directory within quotations ("").
# setwd("D:/OneDrive_PSU/The Pennsylvania State University/Epidem class - PSU")
# NOTE: Windows uses a backslash (\) in paths. R uses only a forward slash (/). Leaving backslashes in paths causes errors, so make sure they are replaced with forward slashes.
knitr::include_graphics("figures/intro_r/folder.png")
knitr::include_graphics("figures/intro_r/project1.png")
knitr::include_graphics("figures/intro_r/project2.png")
knitr::include_graphics("figures/intro_r/folder_2.png")
# Note that we don't have to type the full path to data_demo. This is because we have defined the work directory.
# That means that this:
# data_demo <- readr::read_csv("C:/Users/mnd20/web_epidem/data/intro_r/data_demo.csv")
# is equivalent to this:
data_demo <- readr::read_csv("data/intro_r/data_demo.csv")
data_demo
# We can use the str() function (introduced in the data frame section of this page) to see information about the different variables in our demo data:
str(data_demo)
# Summary statistics:
summary(data_demo)
# First lines:
head(data_demo)
# Last lines:
tail(data_demo)
# We create the vector 'DON', which contains DON measurements (in arbitrary units) across a set of samples:
DON <- c(0.1, 2.5, 7.5, 1, 0.9, 3.2, 4.5)
# Example 1:
# In a step-by-step fashion, we calculate the mean of the log-transformed DON values. For each step, we create a new object.
DON_log <- log(DON)
DON_log_mean <- mean(DON_log)
DON_log_mean
# Example 2:
# We can also calculate the mean of the log-transformed DON values by 'nesting' functions within a single line:
DON_log_nest <- mean(log(DON))
DON_log_nest
# Example 3:
# Finally, we can use a pipe to provide a logical flow to work with the data. The pipe links the steps of the calculation, doesn't result in the creation of multiple objects, and is more easily read and interpreted.
DON_log_pipe <- DON %>%
log(.) %>%
mean(.)
DON_log_pipe
# In Example 3, the pipe takes the DON data, transforms it, calculates the mean, and transfers the result to create the object DON_log_pipe. This method doesn't result in populating the working environment with intermediary data objects and multiple lines of disconnected code (like in Example 1) or in potential errors and readability issues (like in Example 2). Using pipes effectively can reduce time troubleshooting and make it easier for you and others to understand what the code should be doing!
# The filter() function works by defining the data source and the specific condition.
filter(data_demo, is.na(fdk))
# In this case, we use 'is.na(fdk)' to filter only for rows where there are missing (NA) observations for the 'fdk' variable.
# Filtering can also be performed with pipes:
data_demo %>%
filter(is.na(fdk))
# Here, we filter for data where column 'var' is exactly equal to 'R' (meaning resistant in this example data) by using the logical operator '=='. Then, we will print all observations where this condition is true.
data_demo %>%
filter(var == "R") %>%
print(n=Inf)
# Now we filter our data by two conditions: column 'var' equals 'R', and column 'trt' equals 'A'. To do this, we use logical operators '==' and connect the two conditions with the '&' symbol.
data_demo %>%
filter(var == "R" & trt == "A") %>%
print(n=Inf)
# We can filter for observations where the column 'sev' (severity) contains a value equal to or greater than 5 with the logical operator '>='.
data_demo %>%
filter(sev >= 5) %>%
print(n=Inf)
# We can also filter by two conditions in sequence. In this example, we filter for observations where column 'fdk' contains a value less than 1. Then we use logical operator '|' to filter observations where column 'fdk' is less than 1 by the second condition, which is that column 'don' is equal to 0.
data_demo %>%
filter(fdk < 1 | don == 0) %>%
print(n=Inf)
# Here, we use select() on our example data to retain only desirable variables (columns):
data_demo %>%
select(trt, var, blk, sev, inc)
# We can achieve the same result by un-selecting undesirable variables as shown below:
data_demo %>%
select(-plot, -yld, -don, -fdk)
# Here we use mutate() to create new variables 'sev_prop' (sev proportion) and 'inc_prop' (inc proportion).  We transform values from original variables 'sev' and 'inc' to populate the cells in these new variable columns.
data_demo %>%
mutate(sev_prop = sev/100,
inc_prop = inc/100)
# In this example, we transform the 'yld' (yield) values from bushels/acre to kg/hectare. Then we create a new variable 'trt_var', that combines the character values in 'trt' and 'var' to create a concatenated character string, which can be used to identify different samples.
data_demo %>%
mutate(yld = yld*67.25,
trt_var = paste0(trt, "_", var))
# First, we group our example data by 'trt' to create meaningful summaries. Then we use statistical functions (mean(), max(), etc.,) within the summarize() function to collect statistics of the selected variables by trt group.
data_demo %>%
group_by(trt) %>%
summarise(sev = mean(sev),
inv = max(inc),
yld = sd(yld))
# In this example, we show that you can group by multiple variables ('var' and 'trt') and then apply summarize to create a meaningful summary.
data_demo %>%
group_by(var, trt) %>%
summarize(sev = mean(sev),
inv = max(inc),
yld = sd(yld))
# Here we reshape our example data to a longer format using pivot_longer(). First we remove unnecessary variable 'plot' and then we collect all variables EXCEPT 'trt', 'var', and 'blk' to be stored in a single column, allowing our data to take on a longer format. We can change column headings at this time to more accurately describe their contents.
data_longer <- data_demo %>%
select(-plot) %>%   # Remove 'plot' variable
pivot_longer(cols = -c(trt, var, blk), # Define variables NOT to be reshaped
names_to = "variables", # Name new column containing variable names
values_to = "values")  # Name new column containing variable values
data_longer
knitr::include_graphics("figures/intro_r/R.png")
knitr::include_graphics("figures/intro_r/RStudio.png")
# Addition:
2+2
# Subtraction:
10-5
# Multiplication:
15*2
# Division:
20/10
# Exponents:
3^3 # or 3**3
# Division to result in a whole number:
10%/%3
# Returning the remainder from the above operation:
10%%3
# Mean:
mean(c(4,10))
# Standard deviation:
sd(c(2,2,4,4,2,2))
# Square root:
sqrt(9)
# Natural log:
log(100)
# Using log and defining the base (here base of 10):
log(100, base = 10)
# Exponentials:
exp(5)
# Absolute value
abs(-7)
# You can use = to assign a value:
a = 2
a
# You can also use <- to assign a value:
b <- 10
b
# You can use the assigned objects to do calculations:
c <- a+b
c
# An object can also be a character string (a series of letters or numbers), or even multiple character strings!
d <- "R is fun"
d
e <- c("R is fun","So is plant pathology!")
e
# Objects can contain multiple numbers:
f <- c(1,2,3,4,5) # the c means concatenate
f
# Objects and numbers can be grouped into a table (more on this later):
g <- data.frame(First = c(1,2,3,4,5),
Second = c("A", "B", "C", "D", "E"))
g
# You cannot use ONLY a number as object name:
1 <- 2
a1 <- 2
# Some words are reserved for specific functions and cannot be used:
NA <- 200
NaN <- 150
TRUE <-100
FALSE <- 50
Inf <- 0
# Other keywords that cannot be used as object name include:
# "break", "else", "for", "if", "next", "repeat", "return", and "while".
# You also cannot use specific keyboard symbols, such as /, @, %, !, etc.:
UCR/fito <- 100
UCR@fito <- 100
UCR%fito <- 100
# The mean() function calculates the mean of a set of values or of a numeric object:
mean(c(1, 2, 3, 4, 5))
# If you also use 'mean' as an object name, you and others may get confused, and depending on the circumstances, you may get a weird result:
mean <- c(1, 2, 3, 4, 5)
mean(mean)
# We will learn how to create better plots later, but just for example:
# Load ggplot2, a package that is useful for making high-quality plots:
library(ggplot2)
# Assign some arbitrary data to object 'data_plot':
data_for_plot = data.frame(x=c(1,2,3,4,5,6), y=c(1,2,3,4,5,6))
# Create the data object 'plot_name' with instructions on how to build a plot:
plot_name = ggplot(data_for_plot, aes(x = x, y=y)) + geom_point()
# Now that our plot has a name, we can easily view it:
plot_name
# By using our plot's name (plot_name), we can save our plot or add other features to it without re-creating it.
# Save our plot:
ggsave("our_plot.png", plot=plot_name, device="png")
# Add more aesthetic detail to our plot:
plot_name + geom_point(aes(colour=x))
# Let's create an example of a group of numeric values:
numeric_example <- c(1.2, 1.5, 3.14, 2.7182)
# You can directly ask if object 'numeric_example' is numeric with the is.numeric() function:
is.numeric(numeric_example)
# Or determine the data class of the object with the class() function:
class(numeric_example)
# Let's start by creating a vector of numbers:
integer_example <- c(1,5,7,-4)
# See if the new vector is an integer-class data type:
is.integer(integer_example)
# If is not integer, what is the class type?
class(integer_example)
# When you information as numbers, R will assume that is numeric.
# We have to inform R that that the values are integers by using the function as.integer()
integer_exemple <- as.integer(c(1,5,7,-4))
is.integer(integer_exemple)
class(integer_exemple)
# Now, if you enter information that has decimals and force the result to be an integer,
# R will ignore the decimal information
as.integer(c(3.1, 4.9, 5.499999, 9.99999))
# If you enter information as words (= class, character) and try to force this to be an integer
# R will return an error
as.integer(c("Sunday", "Monday", "Tuesday", "Wednesday"))
# If you enter numerical values in character format, it works because numbers can be character values
number_character <- c("1", "2", "3")
class(number_character)
as.integer(number_character)
class(as.integer(number_character))
# This type of transformation is very useful for some data loading in R where the values can be considered as characters
# As mentioned earlier, logical values can be only be considered as TRUE or FALSE:
logical_example <- c(TRUE, FALSE, T, F)
is.logical(logical_example)
# Logical operations are very important for situations where you want to check specific conditions.
# For example, if one number is greater than then other:
5 > 10        # five is greater than 10?
# Also, if character strings are "equal" or identical:
"Sunday" == "Monday"  # Sunday is equal to Monday?
identical("Sunday","Monday")
# You can also check that character strings are not 'equal' or identical:
"Sunday" != "Tuesday" # Sunday is different to Tuesday?
# Here is an example where R interprets that the character "2" should actually be numeric, allowing the logical statement to be interpreted as TRUE:
1 < "2"
# Character values are basic word elements (including numbers) or phrases:
character_example <- c("banana", 'epidemiology', "TRUE", "11", "A character can be more than a single word")
is.character(character_example)
# Character values can be defined using either quotation marks ("") or apostrophes (''):
character_example
# But if you forget to include the " or ', R will give you an error message because R thinks that it is an object!
# Compare:
character_example <- c("banana", epidemiology)
# vs.
character_example <- c("banana", "epidemiology")
# Factors are ordinal, in contrast to character values. This means they have a defined order or level.
factor_example <- as.factor(c("red", 'blue', "green", "red", "red"))
class(factor_example)
# Our example has an order and has levels. In this case, the 'order' matches the sequence in which the values were introduced above. R automatically sets the 'levels' by alphabetical order.
factor_example
# A useful function is factor(). With factor(), you can define the order, level, and other attributes. For example, you can change the levels from alphabetical order 'blue','green','red' to any other configuration:
factor_example2 <- factor(c("red", 'blue', "green", "red", "red"), levels = c("red", "blue", "green"))
factor_example2
# You can also change the name of the elements by changing the level label
factor_example3 <- factor(c("red", 'blue', "green", "red", "red", "yellow"),
levels = c("red", "blue", "green", "yellow"),
labels = c("RED", "Blue", "green", "green"))
factor_example3
# The result from us adding a new color, yellow, is that we redefined what 'yellow' means. # In this case, 'yellow' now results in green. We also changed the format for 'red' and 'blue' to include upper-case letters.
# The most common date format is POSIX (Portible Operating System Interface).
# POSIX describes the date and time, to the millisecond in a string format:
as.POSIXct("2021-04-25 11:30:45")
# You can use different time zones and date formats by defining format and tz parameters. # In the example above, we write the date as year-month-date. We can easily convert other # date formats and define time zone with the as.POSIXct() function, as shown in the next example.
# The date in New Zealand may be written as day/month-year. We tell the as.POSIXct() function to expect this format by typing format = "%d/%m-%Y. We also tell the as.POSIXct() function that the time zone is in New Zealand with tz = "NZ". If the tz parameter is not defined, R assumes the time zone.
as.POSIXct("25/04-2021 14:30:45",
format = "%d/%m-%Y %H:%M:%OS",
tz = "NZ")
# If the tz parameter is not defined, R assumes the time zone.
# Also, note that we used /(slash) instead of - (dash). This is to demonstrate that R can deal with date information in many different formats that data may come in.
# This means that we can use different formats, and as.POSIXct() function still will print information using the default POSIX format.
# There are two functions which we can use: as.POSIXct() and as.POSIXlt(), which create
# different classes of dates and times.
ct <- as.POSIXct("2021-04-05 11:30:45")
lt <- as.POSIXlt("2021-04-05 11:30:45")
class(ct)
class(lt)
# Although they are technically different classes of objects, both outputs look the same:
ct
lt
# The difference between these two classes are in their internal components. Internally, ct retains the number of seconds since 1970-01-01 and is generally preferable for use in data sets. lt retains the # full date and time in it's format, and is generally more readable to humans.
unclass(ct) # The big number is the total of seconds since 1970-01-01
unclass(lt)
# Despite the difference in internal structure, it is possible to extract specific information, for example, year, month, day, etc. from both.
weekdays(ct)
months(lt)
quarters(ct)
# Another function and class we can use for date information is as.Date(), which
# produces a Date object.
dt <- as.Date("2021-04-25 11:30:45")
dt
class(dt)
# As you can see, they are similar to POSIX functions. However, they include only the specified information. For example, if you only provide the date, only the date will be stored. This is in contrast to the as.POSIX() functions, which will infer and store a time zone.
dt <- as.Date("2021-04-25")
dt
ct <- as.POSIXct("2021-04-25")
ct
knitr::include_graphics("figures/intro_r/data_structure.png")
# You can use the function c(), which means concatenate, to create vectors
x <- c(1, 2, 3, 4)
y <- c("a", "b", "c", "d")
x
y
# You can select an element within a vector using square brackets [].
y[3] # This will extract and provide the third element in vector y.
# Here's an example of a matrix containing numbers 1 to 12. With 'ncol' and 'nrow' arguments, we construct a matrix with 3 columns and 4 rows:
matrix_a <- matrix(1:12,ncol=3,nrow=4)
matrix_a
# To extract elements from a matrix, you have to specify first the row and then the column:
matrix_a[2,3]
# If we don't know how big a matrix is, we can see its dimensions using the dim() function:
dim(matrix_a)
# Names can be added to rows and columns by using the option 'dimnames':
matrix(1:12,nrow=4,ncol=3 ,
dimnames = list(c("A", "B", "C", "D"),
c("X", "Y", "Z")))
# Arrays can be constructed with the 'dim' argument specifying the number of rows, columns, and matrices.
array_a <- array(1:36,dim=c(3,4,3)) # 3 matrices with 3 rows and 4 columns each.
array_a
# Note that the array is presented as multiple matrices, allowing us to see all of its values.
# You can also add row, column, and matrix names with the 'dimnames' argument.
array_a =  array(1:36,dim=c(4,3,3),
dimnames = list(c("A", "B", "C", "D"),
c("X", "Y", "Z"),
c("First", "Second", "Third")))
# Similar to vectors and matrices, you can extract elements by using [ ] (brackets)
array_a[2,1,2] # This is the value at row 2, column 1, of matrix layer 2.
array_a[1,1,1] # This is the value at row 1, column 1, of matrix layer 1.
# If you do not indicate one or more of the values, R will collect for all of the other dimensions not specified
array_a[,1,] # This extracts the first column from all matrices in the array.
array_a[1,1,] # This extracts the value in row 1, column 1 of all 3 matrices in array_a.
# Here we construct a numeric vector, a character vector, and a logical vector.
vec_numer <- c(1,2,3,4,5)
vec_char <- c("A", "B", "C", "D", "E")
vec_logic <- c(T, F, T, F, T)
# We use the data.frame() function to group our vectors together in a data frame.
df <- data.frame(vec_numer, vec_char, vec_logic)
df
# The str function will show the class of the vectors composing the data frame.
str(df)
# To select an column in data.frame you can use $ symbol.
df$vec_char
# Just like in other data structures, we can use the square brackets [] to extract values in specific rows and columns.
df[2,2] # This is the value in row 2, column 2 of the data frame.
# Here we construct a scalar, numeric vector, matrix, array, and data frame containing both numeric and character values and store them all in a list:
a <- 2
b <- c(1,2,3,4,5)
c <- matrix(1:20,4,5)
d <- array(1:40, c(4,5,2))
e <- data.frame(numbers = c(1:5),
characters = LETTERS[1:5])
first_list <- list(a, b, c, d, e)
first_list
# We can inspect the composition of the list with str(), just like we can with data frames:
str(first_list)
# You can add names to each data structure:
second_list <- list(scalar = a, vector = b, matrix = c, array = d, data_frame = e)
second_list
# A list can include another list:
third_list <- list(scalar = a, vector = b,  data_frame = e, my_list = second_list)
third_list
# Using [] (brackets), we can extract different components/elements from within the list
third_list[[3]] # Extract the 3rd component/element, data frame 'e'.
third_list[[3]][2] # Extract the 2nd column (characters) of the 3rd element (data frame 'e').
third_list[[3]][1,2] # Extract the value in the 1st row and the 2nd column of the 3rd element.
FUN_weather <- function(x){
daily_weather = paste0("Today the weather is ", x)
print(daily_weather)
}
FUN_weather("good")
FUN_weather("rainy")
FUN_weather("hot!!!")
# Here we create the function 'FUN_go_out'. This function will tell us if it's a good idea to go outside based on temperature (x), rain (y), and whether you are busy or not (z).
FUN_go_out <- function(x = 15, y = "rain", z = "busy"){
cond <-  ifelse(x >=  22 &
y == "sunny" &
z == "not_busy",
"YES", "NO")
output<- paste0("Is it a good day to go out? ", cond)
print(output)
}
# We can use the function we've created above by calling the function and giving it the inputs '15','rain', and 'busy':
FUN_go_out(15,"rain","busy")
# Here we run the function without changing any pre-defined values:
FUN_go_out()
FUN_go_out(x = 25, y = "sunny", z = "not_busy")
FUN_go_out(25, "sunny", "not_busy")
# In this example, we do not define z as "busy" or "not_busy". R will use the default value (z="busy") that is used in the function's definition.
FUN_go_out(x = 25, "sunny")
# The above line of code will produce the same result as if we had written:
FUN_go_out(x=25,"sunny","busy")
# In this example, R knows which order x, y, and z should go in and is able to complete the computation:
FUN_go_out(z = "not_busy", x = 25, y = "sunny")
# In this example, the arguments are not labeled. As a result, R does not know where to use each value.
FUN_go_out("not_busy",25,"sunny")
knitr::include_graphics("figures/intro_r/packages.png")
# Here we create an example matrix to perform functions 't' on:
matrix_1 <- matrix(1:9, 3,3)
matrix_1
# Now, let us transpose this matrix (switch columns to rows and vice versa), using the function t() from base R, which is already installed and loaded:
t(matrix_1)
# So far, so good! But now if we create a function called 't', we may obtain an answer we did not expect. In our new function 't', we mean to add 10 to every input (x) given to the function.
t <- function(x){
x+10 }
# Now if we try to use base R's function 't' to transpose our example matrix, it doesn't work properly:
t(matrix_1)
# Instead, 10 is added to every value within our matrix.
# Therefore, we need to dictate to R which 't' function should be applied by specifying the package name in the following format (package::function):
# If we want to use base 't' to transpose the matrix:
base::t(matrix_1)
# Here, we show how to use the 'help' and '?' functions to pull up information on a function 'cor.test':
help(cor.test)
?(cor.test)
knitr::include_graphics("figures/intro_r/help.png")
knitr::include_graphics("figures/intro_r/tidyverse.png")
# Load tidyverse
library(tidyverse)
# See the current work directory:
getwd()
# Use the function 'setwd()' with the path to your desired work directory within quotations ("").
# setwd("D:/OneDrive_PSU/The Pennsylvania State University/Epidem class - PSU")
# NOTE: Windows uses a backslash (\) in paths. R uses only a forward slash (/). Leaving backslashes in paths causes errors, so make sure they are replaced with forward slashes.
knitr::include_graphics("figures/intro_r/folder.png")
knitr::include_graphics("figures/intro_r/project1.png")
knitr::include_graphics("figures/intro_r/project2.png")
knitr::include_graphics("figures/intro_r/folder_2.png")
# Note that we don't have to type the full path to data_demo. This is because we have defined the work directory.
# That means that this:
# data_demo <- readr::read_csv("C:/Users/mnd20/web_epidem/data/intro_r/data_demo.csv")
# is equivalent to this:
data_demo <- readr::read_csv("data/intro_r/data_demo.csv")
data_demo
# We can use the str() function (introduced in the data frame section of this page) to see information about the different variables in our demo data:
str(data_demo)
# Summary statistics:
summary(data_demo)
# First lines:
head(data_demo)
# Last lines:
tail(data_demo)
# We create the vector 'DON', which contains DON measurements (in arbitrary units) across a set of samples:
DON <- c(0.1, 2.5, 7.5, 1, 0.9, 3.2, 4.5)
# Example 1:
# In a step-by-step fashion, we calculate the mean of the log-transformed DON values. For each step, we create a new object.
DON_log <- log(DON)
DON_log_mean <- mean(DON_log)
DON_log_mean
# Example 2:
# We can also calculate the mean of the log-transformed DON values by 'nesting' functions within a single line:
DON_log_nest <- mean(log(DON))
DON_log_nest
# Example 3:
# Finally, we can use a pipe to provide a logical flow to work with the data. The pipe links the steps of the calculation, doesn't result in the creation of multiple objects, and is more easily read and interpreted.
DON_log_pipe <- DON %>%
log(.) %>%
mean(.)
DON_log_pipe
# In Example 3, the pipe takes the DON data, transforms it, calculates the mean, and transfers the result to create the object DON_log_pipe. This method doesn't result in populating the working environment with intermediary data objects and multiple lines of disconnected code (like in Example 1) or in potential errors and readability issues (like in Example 2). Using pipes effectively can reduce time troubleshooting and make it easier for you and others to understand what the code should be doing!
# The filter() function works by defining the data source and the specific condition.
filter(data_demo, is.na(fdk))
# In this case, we use 'is.na(fdk)' to filter only for rows where there are missing (NA) observations for the 'fdk' variable.
# Filtering can also be performed with pipes:
data_demo %>%
filter(is.na(fdk))
# Here, we filter for data where column 'var' is exactly equal to 'R' (meaning resistant in this example data) by using the logical operator '=='. Then, we will print all observations where this condition is true.
data_demo %>%
filter(var == "R") %>%
print(n=Inf)
# Now we filter our data by two conditions: column 'var' equals 'R', and column 'trt' equals 'A'. To do this, we use logical operators '==' and connect the two conditions with the '&' symbol.
data_demo %>%
filter(var == "R" & trt == "A") %>%
print(n=Inf)
# We can filter for observations where the column 'sev' (severity) contains a value equal to or greater than 5 with the logical operator '>='.
data_demo %>%
filter(sev >= 5) %>%
print(n=Inf)
# We can also filter by two conditions in sequence. In this example, we filter for observations where column 'fdk' contains a value less than 1. Then we use logical operator '|' to filter observations where column 'fdk' is less than 1 by the second condition, which is that column 'don' is equal to 0.
data_demo %>%
filter(fdk < 1 | don == 0) %>%
print(n=Inf)
# Here, we use select() on our example data to retain only desirable variables (columns):
data_demo %>%
select(trt, var, blk, sev, inc)
# We can achieve the same result by un-selecting undesirable variables as shown below:
data_demo %>%
select(-plot, -yld, -don, -fdk)
# Here we use mutate() to create new variables 'sev_prop' (sev proportion) and 'inc_prop' (inc proportion).  We transform values from original variables 'sev' and 'inc' to populate the cells in these new variable columns.
data_demo %>%
mutate(sev_prop = sev/100,
inc_prop = inc/100)
# In this example, we transform the 'yld' (yield) values from bushels/acre to kg/hectare. Then we create a new variable 'trt_var', that combines the character values in 'trt' and 'var' to create a concatenated character string, which can be used to identify different samples.
data_demo %>%
mutate(yld = yld*67.25,
trt_var = paste0(trt, "_", var))
# First, we group our example data by 'trt' to create meaningful summaries. Then we use statistical functions (mean(), max(), etc.,) within the summarize() function to collect statistics of the selected variables by trt group.
data_demo %>%
group_by(trt) %>%
summarise(sev = mean(sev),
inv = max(inc),
yld = sd(yld))
# In this example, we show that you can group by multiple variables ('var' and 'trt') and then apply summarize to create a meaningful summary.
data_demo %>%
group_by(var, trt) %>%
summarize(sev = mean(sev),
inv = max(inc),
yld = sd(yld))
# Here we reshape our example data to a longer format using pivot_longer(). First we remove unnecessary variable 'plot' and then we collect all variables EXCEPT 'trt', 'var', and 'blk' to be stored in a single column, allowing our data to take on a longer format. We can change column headings at this time to more accurately describe their contents.
data_longer <- data_demo %>%
select(-plot) %>%   # Remove 'plot' variable
pivot_longer(cols = -c(trt, var, blk), # Define variables NOT to be reshaped
names_to = "variables", # Name new column containing variable names
values_to = "values")  # Name new column containing variable values
data_longer
